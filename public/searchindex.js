var relearn_searchindex = [
  {
    "breadcrumb": "Bonus Exercises",
    "content": "üëà Back Next üëâ",
    "description": "üëà Back Next üëâ",
    "tags": [],
    "title": "Updating remotely",
    "uri": "/zymbit-tutorial/chapter5/page1/index.html"
  },
  {
    "breadcrumb": "Configuring Zymkey",
    "content": "Now that our Pi is up and running, and the Zymkey is installed, it‚Äôs time to install the Zymbit software that we will need in order to commnicate with the device.\nInstalling zkifc All of these steps are covered in greater detail in the documentation, so if anything here is confusing, you can always double-check there.\nNext, we need to install the required Zymkey Software.\ncurl -G https://s3.amazonaws.com/zk-sw-repo/install_zk_sw.sh | sudo bash Will install any updates, and then download and install the required Zymbit software.\nCaution Installing this software will trigger an automatic reboot of the Pi, so you should not be doing anything else with it while the software is installing.\nAfter the reboot has completed, you should notice that the blue light is no longer flashing rapidly, but is flashing once every 3 seconds. This is your indication that the Zymbit software is properly installed, and able to communicate with the Zymkey.\nIf you‚Äôd like to test to make sure that the Zymkey is installed and functioning properly, you can download and install the test scripts:\nwget https://community.zymbit.com/uploads/short-url/eUkHVwo7nawfhESQ3XwMvf28mBb.zip unzip eUkHVwo7nawfhESQ3XwMvf28mBb.zip sudo mkdir -p /usr/local/share/zymkey/examples/ sudo mv *.py /usr/local/share/zymkey/examples/ python3 /usr/local/share/zymkey/examples/zk_app_utils_test.py Testing data lock... Original Data 01 02 03 04 Encrypted Data 8B B8 06 67 00 00 35 80 82 75 AA BE 89 8C A8 D5 6D 7B 71 48 83 47 B9 9A B7 3A 09 58 41 E6 33 BC 4E 48 7A 32 3A B0 26 D8 59 4F 8C 58 59 97 03 20 3C 99 CF AF 2D CC 47 E5 1B AB 83 FC 6A 3D DE D8 F3 24 9F 73 B5 72 B7 0D 77 8E C6 A8 A3 B3 22 D6 94 8F BD 6A 6C 96 38 EE Testing data unlock... Decryped Data 01 02 03 04 Turning LED on... Testing get_random() with 512 bytes... B7 B6 BD 78 C6 62 7A CC 80 E0 BD 04 C7 43 29 AC 7A 48 2D 3F E5 43 33 AA 7C 37 F6 BA 7D 3F F2 D3 A9 4B B3 A9 16 4C FD AD 48 61 72 9E 7F B9 09 AE A7 4A 4F 54 0D CE 6E 85 E6 87 F5 8C D6 58 4B 0E 12 03 4C 71 BD 3A F0 34 79 06 66 5E 65 DC 6E CF AF 12 72 C1 F1 5D 24 79 A8 D0 F9 40 3E 8E 59 D7 5C ED C5 1E 0E FF 4A 04 69 22 54 F5 13 A1 2E A7 3C B4 CD 30 E7 61 10 B7 E5 07 AD DC E0 FF E9 6E 58 32 50 DA 9F 33 51 F5 8C 16 B5 0C 0F 57 08 E6 E8 00 89 79 DF 16 2A BD FC 27 E0 E4 6C 1B 05 28 EB DE 5B 63 2E F0 E0 21 E8 C5 39 31 26 2A E5 64 79 31 04 7A 60 ED D7 32 6A 8B 4A 29 DD 79 EC D9 2B 72 AC 2E 9A 08 FF 56 06 DB 1C 91 FF D9 3F 10 3E 57 9C 5E B4 32 FD 2E 09 BF 8D 04 6A C8 12 88 06 7C C1 93 FD F7 61 47 90 DD 0D 50 78 78 6C 83 0A 94 DD 5E 9D 83 3F FD 0B 1E 73 23 72 0D 4D D1 82 1F 42 DB EE 1E 7F 85 B9 F1 94 24 54 1B 28 2E 47 24 05 8B 17 0B AE 90 6A DF 0B BC E1 53 B2 96 1C 87 D4 FD A0 EC FC 85 E4 9F 04 F6 B8 E0 37 B2 40 17 33 3A FA 96 01 0C B2 4C 4D FE E7 64 0E 87 4E 4B A8 D0 97 C6 A5 42 F4 02 E4 CC 7C 2B 3A A8 C7 33 22 3C 76 1C 40 42 1F 5A 78 7B 23 FB 0B 39 BD 9F 38 13 6B FE D9 54 C9 D2 F3 97 C6 39 F3 09 9C 6B DC 82 C1 25 99 70 8B 2B 46 FD CD 51 C9 09 20 16 DA 4C D3 58 B6 BB D7 C3 E4 A9 34 F0 5C 85 D7 19 6D A8 F7 26 D6 41 6F 27 04 2C A0 C4 50 9D 28 43 0D DC E2 7E D4 9E 29 FE 45 B2 BF 14 77 A7 AD F4 43 4B 51 85 85 06 7F 02 BF 21 DA C4 BD A4 9B 94 71 FA 21 8B 9E B6 07 48 7F 50 A7 CF 32 2F 8F 98 A1 E1 FE 1B 2E 24 B5 BF 69 E7 DE 3D 11 6C 48 5B 56 5C BF 96 FB 30 BB 86 13 C4 53 61 AD 6E 09 0C A9 4B C1 2F 12 3F BF 34 FB 01 D7 62 13 7A Turning LED off... Flashing LED off, 500ms on, 100ms off... Testing zkCreateRandDataFile with 1MB... Turning LED off... Testing get_ecdsa_public_key()... 20 AD 20 7A 0E D9 A5 81 BF 44 80 54 C6 DC A7 8C D1 D5 7B EE 6D C5 E3 B4 92 8C 0E BF 42 6E D9 9E AA 04 29 CD 4C D9 3A BC 58 5B DD 47 43 39 30 C8 2E FD C6 D9 C9 82 60 06 A4 A0 7F EA F9 C0 76 E9 Testing create_ecdsa_public_key_file()... $ python3 /usr/local/share/zymkey/examples/zk_crypto_test.py Signing data...OK Verifying data...OK Verifying tainted data...FAIL, yay! Generating random block from Zymkey (131072 bytes)... Encrypting random block... Decrypting encrypted block... PASS: Decrypted data matches original random data Done! Success! At this point, your Pi is up and running, and your Zymkey should be functioning properly. Congratualtions! We‚Äôre almost there.\nüëà Back Next üëâ",
    "description": "Now that our Pi is up and running, and the Zymkey is installed, it‚Äôs time to install the Zymbit software that we will need in order to commnicate with the device.\nInstalling zkifc All of these steps are covered in greater detail in the documentation, so if anything here is confusing, you can always double-check there.\nNext, we need to install the required Zymkey Software.\ncurl -G https://s3.amazonaws.com/zk-sw-repo/install_zk_sw.sh | sudo bash Will install any updates, and then download and install the required Zymbit software.",
    "tags": [],
    "title": "Install zkifc",
    "uri": "/zymbit-tutorial/chapter4/page1/index.html"
  },
  {
    "breadcrumb": "Pi Software",
    "content": "Download Pi Imager The Pi Imager software from the Raspberry Pi Foundation is the easiest way to create a proper OS image for your Raspberry Pi. You can download the Pi Imager software and then follow the instructions to install for your platform.\nüëà Back Next üëâ",
    "description": "Download Pi Imager The Pi Imager software from the Raspberry Pi Foundation is the easiest way to create a proper OS image for your Raspberry Pi. You can download the Pi Imager software and then follow the instructions to install for your platform.\nüëà Back Next üëâ",
    "tags": [],
    "title": "Pi Imager",
    "uri": "/zymbit-tutorial/chapter3/page1/index.html"
  },
  {
    "breadcrumb": "Hardware",
    "content": "Assembling the hardware Luckily, there isn‚Äôt much for us to do here (especially since we aren‚Äôt using the CR1025 battery), but there is some.\nUnpack everything We can take all the components out of their boxes, bags, etc. to start with. We won‚Äôt need the packaging again, so you can throw it away unless you want to reuse it.\nInstall the Zymkey The only assembly we need to do is to install the Zymkey on the Raspberry Pi.\nThe Zymkey needs to be fully seated on the header pins of the Raspberry Pi. It should line up with then end of the header pins on the end closest to the display connector.\nüëà Back Next üëâ",
    "description": "Assembling the hardware Luckily, there isn‚Äôt much for us to do here (especially since we aren‚Äôt using the CR1025 battery), but there is some.\nUnpack everything We can take all the components out of their boxes, bags, etc. to start with. We won‚Äôt need the packaging again, so you can throw it away unless you want to reuse it.\nInstall the Zymkey The only assembly we need to do is to install the Zymkey on the Raspberry Pi.",
    "tags": [],
    "title": "Hardware Assembly",
    "uri": "/zymbit-tutorial/chapter2/page1/index.html"
  },
  {
    "breadcrumb": "Overview",
    "content": "Why are we doing this? SD Card vulernability While that micro SD card boot mechanism is certainly convenient, it does leave the Pi extremely vulnerable to physical tampering. After all, someone can simply walk up to the Pi, remove the SD card, and they have access to all of the programs and data that was running. They can put that card into their own Pi and they have full access to everything. Well, with a little password hacking, etc.\nMaking that Pi absolutely secure against physical tampering as well as electronic tampering is a critical step in making a Raspberry Pi a secure device for deploying applications in the field.\nUpdates and recoverability Seamless updates of your Pi is also, often, a hassle. Especially if you have more than a handful of them. You have to login to each one, run the updates, and then hope that nothing goes wrong.\nWhich leads me to recoverability. What happens if one of those updates fails for some reason? especially if it‚Äôs in some remote location. How do you ensure that device is recoverable, and how can you get it back online as quickly as possible?\nüëà Back Next üëâ",
    "description": "Why are we doing this? SD Card vulernability While that micro SD card boot mechanism is certainly convenient, it does leave the Pi extremely vulnerable to physical tampering. After all, someone can simply walk up to the Pi, remove the SD card, and they have access to all of the programs and data that was running. They can put that card into their own Pi and they have full access to everything.",
    "tags": [],
    "title": "Background Info",
    "uri": "/zymbit-tutorial/chapter1/page1/index.html"
  },
  {
    "breadcrumb": "",
    "content": "Background The venerable Raspberry Pi has been around for over a decade (officially created in 2009) and it has become a standard in many robotics, home automation, and other types of uses. Especially for ‚Äúmakers‚Äù and other tinkerers. But it has also made serious inroads into the professional and enterprise world ‚Äì just more quietly.\nIt‚Äôs a capable, reliable, and powerful Single Board Computer (SBC) with a robust user community. For all it‚Äôs strengths, it does have a few notable weaknesses. The biggest one is security. Not because the SBC itself is insecure. and not because the Operating System (OS) is insecure (it runs Linux, which can be very well secured). The most vulnerable part of the Raspberry Pi is the fact that it boots and runs off of a micro SD card.\nLots to cover Clearly we‚Äôre going to cover a lot of ground, but in the end you‚Äôll have a Raspberry Pi that is secure from physical tampering making it virtually impossible to steal your programs and data, remotely updateable in a secure, recoverable fashion, and able to transmit data securely.\nSo let‚Äôs get started!\nüëà Back Next üëâ",
    "description": "Background The venerable Raspberry Pi has been around for over a decade (officially created in 2009) and it has become a standard in many robotics, home automation, and other types of uses. Especially for ‚Äúmakers‚Äù and other tinkerers. But it has also made serious inroads into the professional and enterprise world ‚Äì just more quietly.\nIt‚Äôs a capable, reliable, and powerful Single Board Computer (SBC) with a robust user community. For all it‚Äôs strengths, it does have a few notable weaknesses.",
    "tags": [],
    "title": "Overview",
    "uri": "/zymbit-tutorial/chapter1/index.html"
  },
  {
    "breadcrumb": "Bonus Exercises",
    "content": "üëà Back",
    "description": "üëà Back",
    "tags": [],
    "title": "Signing Data",
    "uri": "/zymbit-tutorial/chapter5/page2/index.html"
  },
  {
    "breadcrumb": "Configuring Zymkey",
    "content": "Finally, making it secure Now that we have a proper security device installed, tested, and ready let‚Äôs secure this thing. At the very same time, let‚Äôs make sure that we can securely update the device when the time comes, and that it is built to be recoverable in case an update fails.\nOrdinarily this would be a ton of work, but we‚Äôre going to simplify everything and do it pretty much all at once.\nA place to put the backup image Since we will be using Bootware(r) to secure our device, we will need a place for the system to copy the entire SD Card as it encrypts it. For this, we‚Äôre going to use a USB Drive.\nWe need to make sure that we can use our USB Drive properly. I often re-use them for other tasks, so here‚Äôs how I like to start out. After plugging the USB Drive in, I make sure to ‚Äúzero out‚Äù the drive, then create a brand new partition map and file system on it.\nsudo dd if=/dev/zero of=/dev/sda bs=512 count=1 conv=notrunc 1+0 records in 1+0 records out 512 bytes copied, 0.0197125 s, 26.0 kB/s That clears the previous file system, if any.\nsudo fdisk -W always /dev/sda Welcome to fdisk (util-linux 2.38.1). Changes will remain in memory only, until you decide to write them. Be careful before using the write command. Device does not contain a recognized partition table. Created a new DOS (MBR) disklabel with disk identifier 0x27b0681a. Command (m for help): n Partition type p primary (0 primary, 0 extended, 4 free) e extended (container for logical partitions) Select (default p): p Partition number (1-4, default 1): First sector (2048-125313282, default 2048): Last sector, +/-sectors or +/-size{K,M,G,T,P} (2048-125313282, default 125313282): Created a new partition 1 of type 'Linux' and of size 59.8 GiB. Partition #1 contains a ext4 signature. The signature will be removed by a write command. Command (m for help): w The partition table has been altered. Calling ioctl() to re-read partition table. Syncing disks. The important parts there are, once you‚Äôve entered the sudo fdisk -W always /dev/sda you will enter n to create a new partition map. Then p to make it a Primary partition, and finally w to write the partition map to the disk. For everything else, I just accept the defaults as presented.\nFinally, now that we have a partitioned USB Drive, we have to create a proper file system on it.\nsudo mkfs.ext4 -j /dev/sda1 -F mke2fs 1.47.0 (5-Feb-2023) Creating filesystem with 15663904 4k blocks and 3916304 inodes Filesystem UUID: 4a3af5d0-bac4-4903-965f-aa6caa8532cf Superblock backups stored on blocks: 32768, 98304, 163840, 229376, 294912, 819200, 884736, 1605632, 2654208, 4096000, 7962624, 11239424 Allocating group tables: done Writing inode tables: done Creating journal (65536 blocks): done Writing superblocks and filesystem accounting information: done You should now have a proper file system on the USB Drive, which we will use as our space for creating our secure boot image next.\nüëà Back Next üëâ",
    "description": "Finally, making it secure Now that we have a proper security device installed, tested, and ready let‚Äôs secure this thing. At the very same time, let‚Äôs make sure that we can securely update the device when the time comes, and that it is built to be recoverable in case an update fails.\nOrdinarily this would be a ton of work, but we‚Äôre going to simplify everything and do it pretty much all at once.",
    "tags": [],
    "title": "Preparing for Bootware‚Ñ¢",
    "uri": "/zymbit-tutorial/chapter4/page2/index.html"
  },
  {
    "breadcrumb": "Pi Software",
    "content": "Starting Pi Imager When you first start the Pi Imager, you‚Äôll see that you have to make some choices:\nFirst, you‚Äôll want to choose which Pi model you have. We‚Äôre using Pi 4s\nNext, you‚Äôll choose the Operating System. We are going to use the most recent version (Bookworm, 64-bit), but we won‚Äôt be needing the full Desktop environment, so choose the ‚ÄòLite‚Äô version.\nNext, you‚Äôll identify the Micro SD Card you‚Äôd like to write to. If you haven‚Äôt already, insert the Micro SD Card into SD Card writer and plug it in to your computer.\nThe last step before actually writing the OS to the disk is to set any additional settings you‚Äôd like for the Pi. I recommend at least setting up a hostname and username/password, and if you would like to use your local WiFi, the WiFi credentials.\nFor this exercise, set the following:\nhostname: Choose something unique! We will all be on the same LAN, so make it something unique to this LAN username: I use zymbit for the username, but you can choose whatever you like password: For ease of use, I use zymbit here as well, but that‚Äôs clearly not secure, so choose whatever password you can reliably remember SSID: We will be using a local WiFi Hotspot, so enter zymbit-lab here. password: The WiFi zymbit-lab uses the password zymbit-lab-wifi so enter that here. We will need to login via ssh, so turn on ssh, and allow password logins\nOnce you‚Äôve got all the settings right, it‚Äôs time to write it all to the card. Note that this will completely erase any existing data on the SD Card, so be careful.\nAfter that, you can sit back and enjoy a cup of coffee while your OS is written to the card. Once it‚Äôs done, we can move on to configuring the hardware.\nüëà Back Next üëâ",
    "description": "Starting Pi Imager When you first start the Pi Imager, you‚Äôll see that you have to make some choices:\nFirst, you‚Äôll want to choose which Pi model you have. We‚Äôre using Pi 4s\nNext, you‚Äôll choose the Operating System. We are going to use the most recent version (Bookworm, 64-bit), but we won‚Äôt be needing the full Desktop environment, so choose the ‚ÄòLite‚Äô version.\nNext, you‚Äôll identify the Micro SD Card you‚Äôd like to write to.",
    "tags": [],
    "title": "Creating an image",
    "uri": "/zymbit-tutorial/chapter3/page2/index.html"
  },
  {
    "breadcrumb": "",
    "content": "Overview First, let‚Äôs go over all the hardware and parts in your kit.\nNote You will be taking all of this hardware home with you! It‚Äôs yours to keep.\nTo start off, we‚Äôre going to build a Raspberry Pi from scratch.\nHere are all the parts included in your kit. I will include Amazon links to the ones we are using in this workshop in case you want to resupply later. If you‚Äôre missing any parts, please let me know\nRaspberry Pi (I‚Äôm using a Raspberry Pi 4, but you can also use a Raspberry Pi 5 if you prefer) Power supply for your Pi. It is important to use a good power supply that supplies enough power for the Pi4 or Pi5. The official supply from the Pi foundation is recommended. High quality Micro SD Card I recommend a 32GB card. SD Card Reader/Writer (if there isn‚Äôt one built-in to your computer) High quality USB Flash drive (Note: It should be 2x the size of your SD Card) I like this one from from PNY. Zymkey, HSM4 or HSM6 (I‚Äôm using a Zymkey here, but an HSM6 will work just fine if you want Hardware Signing) CR1025 Battery (a battery is not strictly necessary, but I‚Äôm including it here for completeness. The Zymkey uses it to maintain the Real Time Clock (RTC)) Important We will not be using a CD1025 battery in this workshop. It is only required for operating the Real Time Clock on the Zymmkey, and we won‚Äôt be using that function.\nüëà Back Next üëâ",
    "description": "Overview First, let‚Äôs go over all the hardware and parts in your kit.\nNote You will be taking all of this hardware home with you! It‚Äôs yours to keep.\nTo start off, we‚Äôre going to build a Raspberry Pi from scratch.\nHere are all the parts included in your kit. I will include Amazon links to the ones we are using in this workshop in case you want to resupply later.",
    "tags": [],
    "title": "Hardware",
    "uri": "/zymbit-tutorial/chapter2/index.html"
  },
  {
    "breadcrumb": "Overview",
    "content": "A/B Partitioning Some background here is probably appropriate. The idea of A/B partitioning is an important concept for recoverability. If you have a single disk partition that your devices boots from, and you update critical items in that partition that are somehow corrupted, your device may be left in a state where it is impossible to boot or recover. It‚Äôs bricked. The only way to recover such a device typically is to physically access the device and make direct changes to the SD Card. This is not always practical, or even possible.\nWith A/B partitioning you create dual boot partitions and only run from one. That is the known-good or primary partition. You then have a secondary partition where you can apply updates. Once an update is applied to the secondary partition, the device reboots from that newly updated partition. If the update is successful, your system is back up and running and that partition is then marked as the primary, and it will reboot from that known-good partition from now on.\nIf the update fails for some reason and the device cannot properly boot from the updated partition, the system reboots from the previously used primary partition, and it can continue to run until a fixed update can be deployed.\nWith this partitioning scheme in place, your Pi is much less likely to end up bricked as you can maintain a known-good partition at all times from which to boot.\nBootware encrypts the A, B, and DATA partitions. The A and B partition are locked with unique LUKS keys, meaning you cannot access the Backup partition from the Active partition. The encrypted DATA partition is accessible from either the A or B partition.\nSetting up this A/B partitioning scheme is usually quite cumbersome and difficult to implement. Zymbit‚Äôs Bootware has taken that process and simplified it such that it‚Äôs a relatively easy process. So let‚Äôs go through that process now and make your Pi both secure and resilient.\nüëà Back Next üëâ",
    "description": "A/B Partitioning Some background here is probably appropriate. The idea of A/B partitioning is an important concept for recoverability. If you have a single disk partition that your devices boots from, and you update critical items in that partition that are somehow corrupted, your device may be left in a state where it is impossible to boot or recover. It‚Äôs bricked. The only way to recover such a device typically is to physically access the device and make direct changes to the SD Card.",
    "tags": [],
    "title": "Partitioning for Updates",
    "uri": "/zymbit-tutorial/chapter1/page2/index.html"
  },
  {
    "breadcrumb": "Configuring Zymkey",
    "content": "A place to put the backup image Since we will be using Bootware‚Ñ¢ to secure our device, we will need a place for the system to copy the entire SD Card as it encrypts it. For this, we‚Äôre going to use a USB Drive.\nWe need to make sure that we can use our USB Drive properly. I often re-use them for other tasks, so here‚Äôs how I like to start out. After plugging the USB Drive in, I make sure to ‚Äúzero out‚Äù the drive, then create a brand new partition map and file system on it.\nsudo dd if=/dev/zero of=/dev/sda bs=512 count=1 conv=notrunc 1+0 records in 1+0 records out 512 bytes copied, 0.0197125 s, 26.0 kB/s That clears the previous file system, if any.\nsudo fdisk -W always /dev/sda Welcome to fdisk (util-linux 2.38.1). Changes will remain in memory only, until you decide to write them. Be careful before using the write command. Device does not contain a recognized partition table. Created a new DOS (MBR) disklabel with disk identifier 0x27b0681a. Command (m for help): n Partition type p primary (0 primary, 0 extended, 4 free) e extended (container for logical partitions) Select (default p): p Partition number (1-4, default 1): First sector (2048-125313282, default 2048): Last sector, +/-sectors or +/-size{K,M,G,T,P} (2048-125313282, default 125313282): Created a new partition 1 of type 'Linux' and of size 59.8 GiB. Partition #1 contains a ext4 signature. The signature will be removed by a write command. Command (m for help): w The partition table has been altered. Calling ioctl() to re-read partition table. Syncing disks. The important parts there are, once you‚Äôve entered the sudo fdisk -W always /dev/sda you will enter n to create a new partition map. Then p to make it a Primary partition, and finally w to write the partition map to the disk. For everything else, I just accept the defaults as presented.\nFinally, now that we have a partitioned USB Drive, we have to create a proper file system on it.\nsudo mkfs.ext4 -j /dev/sda1 -F mke2fs 1.47.0 (5-Feb-2023) Creating filesystem with 15663904 4k blocks and 3916304 inodes Filesystem UUID: 4a3af5d0-bac4-4903-965f-aa6caa8532cf Superblock backups stored on blocks: 32768, 98304, 163840, 229376, 294912, 819200, 884736, 1605632, 2654208, 4096000, 7962624, 11239424 Allocating group tables: done Writing inode tables: done Creating journal (65536 blocks): done Writing superblocks and filesystem accounting information: done Note If, like me, you get tired of typing sudo all the time, you can run sudo -i once and get a root prompt from which to run all your commands. But remember, with great power comes great responsibility!\nInstalling Bootware‚Ñ¢ Bootware is the Zymbit tool for securing and updating your Raspberry Pi. It is a powerful tool that allows you to update one, or an entire fleet, or Pis across your enterprise. And it allows you to do it safely, securely, and in a way that is recoverable if something goes wrong.\nFirst, we have to run the installer\ncurl -sSf https://raw.githubusercontent.com/zymbit-applications/zb-bin/main/install.sh | sudo bash This installer will ask you a couple of simple questions, so let‚Äôs go through the answers. The first is whether or not you‚Äôd like to include Hardware Signing. If you have an HSM6 or SCM-based product, you can answer yes to this question. If you‚Äôve got a Zymkey or HSM4, Hardware Signing is not supported, so you don‚Äôt need to install it. Even with software signing, your final LUKS encrypted partitions will be protected by the Zymbit HSM keys.\nNext it will ask you which version of Bootware to install. Choose the most recent version.\nzb-install.sh: bootstrapping the zbcli installer --------- Pi Module: Raspberry Pi 4/Compute Module 4 Operating System: Rpi-Bookworm Zymbit module: Zymkey Kernel: kernel8.img --------- ‚úî 'zbcli' comes with software signing by default. Include hardware key signing? (Requires SCM or HSM6) ¬∑ No ‚úî Select version ¬∑ zbcli-1.2.0-rc.26 Installing zbcli Installed zbcli. Run 'zbcli install' to install Bootware onto your system or 'zbcli --help' for more options. zb-install.sh: cleaning up Now that the installer is ready, it‚Äôs time to install Bootware‚Ñ¢ itself:\nsudo zbcli install The installer will ask you if you‚Äôre ready to reboot when it‚Äôs done:\n--------- Pi Module: Raspberry Pi 4 Operating System: Rpi-Bookworm Zymbit module: Zymkey Kernel: kernel8.img --------- Found kernel '/boot/firmware/kernel8.img' Created '/etc/zymbit/zboot/mnt' Created '/etc/zymbit/zboot/scripts' Created '/etc/zymbit/zboot/zboot_backup' Created '/boot/firmware/zboot_bkup' Installed 'u-boot-tools' Created '/etc/fw_env.config' Created '/usr/bin/zbconfig' Found OpenSSL 3 Created '/boot/firmware/zb_config.enc' Modified zbconfig 'kernel_filename' Installed zboot Modified '/etc/rc.local' Created '/lib/cryptsetup/scripts/zk_get_shared_key' Modified '/boot/firmware/config.txt' Created '/etc/update-motd.d/01-zymbit-fallback-message' Modified /etc/update-motd.d/01-zymbit-fallback-message ‚úî A reboot into zboot is required. Reboot now? ¬∑ yes Finished in 29.1s After the reboot, Bootware should be successfully installed. Now we can move on to creating secure partitions, and preparing for secure updates.\nüëà Back Next üëâ",
    "description": "A place to put the backup image Since we will be using Bootware‚Ñ¢ to secure our device, we will need a place for the system to copy the entire SD Card as it encrypts it. For this, we‚Äôre going to use a USB Drive.\nWe need to make sure that we can use our USB Drive properly. I often re-use them for other tasks, so here‚Äôs how I like to start out.",
    "tags": [],
    "title": "Installing Bootware‚Ñ¢",
    "uri": "/zymbit-tutorial/chapter4/page3/index.html"
  },
  {
    "breadcrumb": "Pi Software",
    "content": "Now it‚Äôs time to plug the Pi in to the power supply, wait for it to boot, and get started setting up our security!\nFirst, let‚Äôs login to your Pi. Remember the hostname you gave it back while you were Configuring your SD Card? You‚Äôll need that, and the username/password that you set. You will also need a terminal application.\nImportant On macOS, you can go to Applications ‚Äì\u003e Utilities ‚Äì\u003e Terminal.app On Linux, and XTerm or Terminal app will work On Windows, you will need Putty or a similar Terminal application\nssh \u003cusername\u003e@\u003chostname.local\u003e Then enter the password you set previously. Since I called my Pi zymbit-pi and set the username and password both to zymbit I would use\nssh zymbit@zymbit-pi.local zymbit@zymbit-pi.local's password: \u003czymbit\u003e ... zymbit-pi:~ $ And you‚Äôre now logged in to your Raspberry Pi!\nBefore we can configure the Zymkey, we need to ensure that the Pi can talk to it. The Zymkey software communicates with the device via I2C, so we need to make sure that the Pi‚Äôs I2C interface is enabled.\n$ sudo raspi-config Gets you to the configuration utility.\nYou‚Äôll then select ‚ÄúInterface Options‚Äù and then ‚ÄúI2C‚Äù\nYou can then exit and save raspi-config\nIt‚Äôs no longer necessary to reboot your Pi after this.\nOne last thing before we continue. It‚Äôs probably a good idea to make sure that the OS is fully up to date. You can run the following 2 commands:\nsudo apt update sudo apt upgrade Tip If you get tired of adding sudo to all of these management commands, you can enter\nsudo -i Which will get you a root shell. But remember, with great power comes great responsibility!\nYou will then want to reboot your Pi to apply all the changes.\nsudo reboot And wait for the reboot to complete.\nüëà Back Next üëâ",
    "description": "Now it‚Äôs time to plug the Pi in to the power supply, wait for it to boot, and get started setting up our security!\nFirst, let‚Äôs login to your Pi. Remember the hostname you gave it back while you were Configuring your SD Card? You‚Äôll need that, and the username/password that you set. You will also need a terminal application.\nImportant On macOS, you can go to Applications ‚Äì\u003e Utilities ‚Äì\u003e Terminal.",
    "tags": [],
    "title": "Pi Configuration",
    "uri": "/zymbit-tutorial/chapter3/page3/index.html"
  },
  {
    "breadcrumb": "",
    "content": "In this section we will do the following:\nInstall the Pi Imager software Image the SD Card for the Raspberry Pi Boot the Raspberry Pi Enable I2C on the Raspberry Pi üëà Back Next üëâ",
    "description": "In this section we will do the following:\nInstall the Pi Imager software Image the SD Card for the Raspberry Pi Boot the Raspberry Pi Enable I2C on the Raspberry Pi üëà Back Next üëâ",
    "tags": [],
    "title": "Pi Software",
    "uri": "/zymbit-tutorial/chapter3/index.html"
  },
  {
    "breadcrumb": "",
    "content": "At this point your Raspberry Pi should be booted and running. The Zymkey should be installed, and the blue light on the Zymkey should be blinking rapidly. The rapid blinking indicates that the Zymkey is powered on, but the Raspberry Pi is not able to communicate with it yet. So let‚Äôs fix that!\nüëà Back Next üëâ",
    "description": "At this point your Raspberry Pi should be booted and running. The Zymkey should be installed, and the blue light on the Zymkey should be blinking rapidly. The rapid blinking indicates that the Zymkey is powered on, but the Raspberry Pi is not able to communicate with it yet. So let‚Äôs fix that!\nüëà Back Next üëâ",
    "tags": [],
    "title": "Configuring Zymkey",
    "uri": "/zymbit-tutorial/chapter4/index.html"
  },
  {
    "breadcrumb": "Configuring Zymkey",
    "content": "Configuring Bootware This is where the real fun begins! If you‚Äôve ever used LUKS to encrypt a Pi filesystem before, you know that, while it‚Äôs a great step in securing your Pi, you still have to store that encryption key somewhere that is accessible at boot time.\nWith Bootware and a Zymbit HSM, the LUKS encryption key is locked by the Zymbit HSM, making it much more secure. Bootware expects the boot image to be in a specific, encrypted format called a z-image. The Bootware CLI tool helps you create and manage these images for deployment across your enterprise.\nSo let‚Äôs create our first z-image, and we‚Äôll use the current system as the basis for it.\nFirst, we need to mount the USB Drive so that we have someplace to put our z-image:\nsudo mount /dev/sda1 /mnt Next, we‚Äôll run the imaging tool to create an encrypted z-image of our current system:\nsudo zbcli imager Validated bootware installation --------- Pi Module: Raspberry Pi 4 Operating System: Rpi-Bookworm Zymbit module: Zymkey Kernel: kernel8.img --------- Created '/etc/zymbit/zboot/update_artifacts/tmp' ‚úî Enter output directory ¬∑ /mnt ‚úî Enter image name ¬∑ z-image-1 ‚úî Select image type ¬∑ Full image of live system ‚úî (Optional) enter image version ¬∑ 1.0 ‚úî Select key ¬∑ Create new software key Notice that I used the mount point for the USB Drive as our output directory. I then chose a name and version number for the image and chose to use a software key, since I‚Äôm using a Zymkey.\nDon‚Äôt be surprised if this step takes a while. What it‚Äôs doing is making a complete copy of the files on the running disk, and signing it with the hardware key that it has generated\nCreated signing key Created '/etc/zymbit/zboot/update_artifacts/file_manifest' Created '/etc/zymbit/zboot/update_artifacts/file_deletions' Verified path unmounted '/etc/zymbit/zboot/mnt' Cleaned '/etc/zymbit/zboot/mnt' Deleted '/etc/crypttab' Verified disk size (required: 2.33 GiB, free: 26.39 GiB) Created initramfs Created snapshot of boot (/etc/zymbit/zboot/update_artifacts/tmp/.tmpBgEBJk/z-image-1_boot.tar) Created snapshot of root (/etc/zymbit/zboot/update_artifacts/tmp/.tmpBgEBJk/z-image-1_rfs.tar) Created '/mnt/tmp' Cleaned '/mnt/tmp' Created staging directory (/mnt/tmp/.tmpEhjNN7) Created '/mnt/tmp/.tmpEhjNN7/header.txt' Created tarball (/mnt/tmp/.tmpEhjNN7/update_artifact.tar) Created header signature Created update artifact signature Created file manifest signature Created file deletions signature Created '/mnt/tmp/.tmpEhjNN7/signatures' Created signatures (/mnt/tmp/.tmpEhjNN7/signatures) Copied file (/etc/zymbit/zboot/update_artifacts/file_manifest) to (/mnt/tmp/.tmpEhjNN7/file_manifest) Copied file (/etc/zymbit/zboot/update_artifacts/file_deletions) to (/mnt/tmp/.tmpEhjNN7/file_deletions) Created tarball (/mnt/z-image-1.zi) Created '/mnt/z-image-1_private_key.pem' Saved private key '/mnt/z-image-1_private_key.pem' Created '/mnt/z-image-1_pub_key.pem' Saved public key '/mnt/z-image-1_pub_key.pem' Cleaned '/mnt/tmp' Saved image '/mnt/z-image-1.zi' (2.33 GiB) Finished in 384.8s The public/private keypair is saved on the USB Drive, and we will need it later.\nIf you remember from the beginning, we will be creating A/B partitions\nBootware encrypts the A, B, and DATA partitions. The A and B partition are locked with unique LUKS keys, meaning you cannot access the Backup partition from the Active partition. The encrypted DATA partition is accessible from either the A or B partition.\nSetting up this A/B partitioning scheme is usually quite cumbersome and difficult to implement. Zymbit‚Äôs Bootware has taken that process and simplified it such that it‚Äôs a relatively easy process. So let‚Äôs go through that process now and make your Pi both secure and resilient.\nCreate A/B partitions Since we‚Äôve not previously had a backup B partition, we will create one, and we will place the current image (which we know is good, since we‚Äôre currently running it) into that partition. To do that, we will update the configuration (really create it) with the zbcli tool.\n$ sudo zbcli update-config Validated bootware installation --------- Pi Module: Raspberry Pi 4 Operating System: Rpi-Bookworm Zymbit module: Zymkey Kernel: kernel8.img --------- Info the root file system will be re-partitioned with your chosen configuration. This process will ask you some questions to determine how to lay out your partitions. The first is what device partition layout you would like to use. Choose the recommended option:\n? Select device partition layout after an update ‚Ä∫ ‚ùØ [RECOMMENDED] A/B: This will take the remaining disk space available after the boot partition and create two encrypted partitions, each taking up half of the remaining space. Most useful for rollback and reco Using partition layout (A/B) Info the root file system will be re-partitioned with your chosen configuration. Next you will select the update policy. Again, just choose the recommended one.\n? Select update policy ‚Ä∫ ‚ùØ [RECOMMENDED] BACKUP: Applies new updates to current backup filesystem and swap to booting the new updated backup partition as the active partition now. If the new update is bad, it will rollback into the pre Running [========================================] 2/1 (00:00:17): WARNING! Detected active partition (28.71GB) is larger than 14.86GB needed for two filesystems. Active partition won't be saved!!! Changing update mode to UPDATE_BOTH!!! Using update mode (UPDATE_BOTH) Data partition size currently set to: 512 MB Info bootware will create a shared data partition after A/B in size MB specified Next, you can select the size of the data partition. It defaults to 512MB, but I suggest increasing that to 1024MB.\n‚úî Enter size of data partition in MB ¬∑ 1024 Using Data Partition Size 1024MB Defaulting to configured endpoint '/dev/sda1' Info update endpoints can be either an HTTPS URL or an external mass storage device like a USB stick. Found update name 'z-image-1' Saved update name 'z-image-1' Using update endpoint '/dev/sda1' Configuration settings saved Finished in 42.1s We‚Äôve now got a system that is configured to have A/B partitioning, and to apply updates to the backup partition when they are available.\nTo complete the process, we will actually apply the update (which is really just a copy of the currently running system). This will trigger the re-partitioning and a reboot.\nüëà Back Next üëâ",
    "description": "Configuring Bootware This is where the real fun begins! If you‚Äôve ever used LUKS to encrypt a Pi filesystem before, you know that, while it‚Äôs a great step in securing your Pi, you still have to store that encryption key somewhere that is accessible at boot time.\nWith Bootware and a Zymbit HSM, the LUKS encryption key is locked by the Zymbit HSM, making it much more secure. Bootware expects the boot image to be in a specific, encrypted format called a z-image.",
    "tags": [],
    "title": "Secure Booting",
    "uri": "/zymbit-tutorial/chapter4/page4/index.html"
  },
  {
    "breadcrumb": "",
    "content": "Now that you have a secure Raspberry Pi it‚Äôs time to see what you can do with it!\nI‚Äôve got 2 exercises you can try:\nUpdate your Pi securely from an external (web) source. Use your Zymkey to create and sign some data üëà Back Next üëâ",
    "description": "Now that you have a secure Raspberry Pi it‚Äôs time to see what you can do with it!\nI‚Äôve got 2 exercises you can try:\nUpdate your Pi securely from an external (web) source. Use your Zymkey to create and sign some data üëà Back Next üëâ",
    "tags": [],
    "title": "Bonus Exercises",
    "uri": "/zymbit-tutorial/chapter5/index.html"
  },
  {
    "breadcrumb": "Configuring Zymkey",
    "content": "Setting up secure booting Before we can set up the partitions, we need to make sure that we have the keys to decrypt the boot image that we created in the previous step. Those keys are stored on the USB Drive, so copy the public key to the local directory:\nsudo mount /dev/sda1 /mnt cp /mnt/z-image-1_pub_key.pem . Now that we have th key close at hand, it‚Äôs time to have Bootware create the secure partitions for us.\nsudo zbcli update Validated bootware installation --------- Pi Module: Raspberry Pi 4 Operating System: Rpi-Bookworm Zymbit module: Zymkey Kernel: kernel8.img --------- Cleaned '/etc/zymbit/zboot/update_artifacts/tmp' Found update configs ? Proceed with current configs? These can be modified through 'zbcli update-config' --------- Update endpoint /dev/sda1 Update name z-image-1 Endpoint type LOCAL Partition layout A/B Update policy UPDATE_BOTH --------- Created temporary directory (/etc/zymbit/zboot/update_artifacts/tmp/.tmpCfhm6c) ‚úî Enter public key file (Pem format) ¬∑ ./z-image-1_pub_key.pem Mounted '/dev/sda1' to '/etc/zymbit/zboot/update_artifacts/tmp/.tmpyKYgR3' Found image tarball (/etc/zymbit/zboot/update_artifacts/tmp/.tmpyKYgR3/z-image-1.zi) Unpacked '/etc/zymbit/zboot/update_artifacts/tmp/.tmpCfhm6c/update_artifact.tar' Unpacked '/etc/zymbit/zboot/update_artifacts/tmp/.tmpCfhm6c/signatures' Unpacked '/etc/zymbit/zboot/update_artifacts/tmp/.tmpCfhm6c/header.txt' Unpacked '/etc/zymbit/zboot/update_artifacts/tmp/.tmpCfhm6c/file_manifest' Unpacked '/etc/zymbit/zboot/update_artifacts/tmp/.tmpCfhm6c/file_deletions' Decoded header signature Decoded image signature Decoded manifest signature Decoded deletions signature Found header data Found image data Found manifest data Found file deletions data Verified header signature Verified image signature Verified manifest signature Verified file deletions signature Modified zbconfig 'public_key' Modified zbconfig 'new_update_needed' Modified zbconfig 'root_a' Modified zbconfig 'root_b' Modified zbconfig 'root_dev' Copied file (/boot/firmware/usr-kernel.enc) to (/boot/firmware/zboot_bkup/usr-kernel-A.enc) Copied file (/boot/firmware/kernel8.img) to (/boot/firmware/zboot_bkup/kernel8.img) Modified zbconfig 'update_with_new_image' Modified zbconfig 'kernel_filename' ? Scheduled update for the next reboot. Reboot now? (y/n) ‚Ä∫ yes When it asks to reboot, say yes, and then wait.\nOnce your Pi is rebooted, log in and check to see that it‚Äôs correct.\nlsblk NAME MAJ:MIN RM SIZE RO TYPE MOUNTPOINTS sda 8:0 1 59.8G 0 disk ‚îî‚îÄsda1 8:1 1 59.8G 0 part mmcblk0 179:0 0 29.7G 0 disk ‚îú‚îÄmmcblk0p1 179:1 0 512M 0 part /boot/firmware ‚îú‚îÄmmcblk0p2 179:2 0 14.1G 0 part ‚îÇ ‚îî‚îÄcryptrfs_A 254:0 0 14.1G 0 crypt / ‚îú‚îÄmmcblk0p3 179:3 0 14.1G 0 part ‚îî‚îÄmmcblk0p4 179:4 0 1G 0 part ‚îî‚îÄcryptrfs_DATA 254:1 0 1008M 0 crypt Notice that we now have two cryptfs devices. These are fully signed and encrypted filesystems.\nWhat if the update had failed? Here‚Äôs the beauty of A/B partitioning with Bootware: if the system fails to boot (it fails to reach a systemd init target for 3 times in a row), Bootware will revert to the known-good partition, bringing your device back on-line.\nCongratulations You now have a Raspberry Pi that has a secure mechanism for signing data and for creating and installing secure boot images!\nüëà Back Next üëâ",
    "description": "Setting up secure booting Before we can set up the partitions, we need to make sure that we have the keys to decrypt the boot image that we created in the previous step. Those keys are stored on the USB Drive, so copy the public key to the local directory:\nsudo mount /dev/sda1 /mnt cp /mnt/z-image-1_pub_key.pem . Now that we have th key close at hand, it‚Äôs time to have Bootware create the secure partitions for us.",
    "tags": [],
    "title": "Enabling Secure Boot",
    "uri": "/zymbit-tutorial/chapter4/page5/index.html"
  },
  {
    "breadcrumb": "",
    "content": "",
    "description": "",
    "tags": [],
    "title": "Categories",
    "uri": "/zymbit-tutorial/categories/index.html"
  },
  {
    "breadcrumb": "",
    "content": "",
    "description": "",
    "tags": [],
    "title": "Tags",
    "uri": "/zymbit-tutorial/tags/index.html"
  }
]
